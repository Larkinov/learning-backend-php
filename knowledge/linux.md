# Linux (UBUNTU) | Bash

#### Официальная документация

[Ubuntu](https://documentation.ubuntu.com/server/)

[Bash](https://tiswww.case.edu/php/chet/bash/bashtop.html)

## Основные команды. Советы

Проверить существует ли команда (в случае если существует, то выведется путь до команды):
```bash
command -v
```

Поиск по предыдущим командам:
```bash
ctrl+r
```

Флаг -h - часто обозначает "human readable" - человекочитаемый формат.

### Пользователи

Узнать пользователя под которым идет сеанс:
```bash
who
```
Получить всех пользователей:
```bash
cat /etc/passwd
```
Зайти под пользователем:
```bash
su name
```
Зайти под рутом:
```bash
sudo -i
```
Создать пользователя:
```bash
useradd name
```
Создать пользователя, добавить его в группы, задать ему оболочку bash, создать ему домашний каталог:
```bash
useradd name -G "group_1,group_2" -s "/bin/bash" -m
```
Изменить настройки пользователя. Опции: -p - пароль, -G - список групп в которых состоит пользователь, -d - домашний каталог, -a - добавить пользователя в группу (используется вместе с -G):
```bash
usermod -опция name
```
Сменить пароль пользователя:
```bash
passwd name
```
Удалить пользователя. Предварительно нужно закрыть все процессы этого пользователя и сделать бэкап необходимых данных:
```bash
passwd -l name
usermod --expiredate 1 name
deluser --remove-all-files name

```

Узнать в каких группах состоит пользователь:
```bash
id -Gn NAME
```

---

### Группы

Создать группу:
```bash
groupadd name_group
```
Получить все группы:
```bash
cat /etc/group
```
Добавить пользователя в группу:
```bash
usermod -aG name_group name
```

---

### Перемещение и ориентация

Подробный вывод файлов из текущей директории:
```bash
ls -l
```
Вывод скрытых файлов и размер файлов:
```bash
ls -luh
```

---

### Каталоги

Изменить владельцев каталога и подкаталогов:
```bash
chown -R odin:sftpusers /path/to/catalog
```
Изменить права доступа каталога и подкаталогов. 775 - это определенные права, если необходимы другие, нужно задать другие:
```bash
chmod -R 775 /path/to/catalog
```
Размер каталога:
```bash
du -sh ./dir
```

Узнать дату изменения:

- Полный вывод
  ```bash
  stat filename
  ```
- Дата изменения в определенном формате
  ```bash
  date -r filename "+date_format"
  ```

---

### Ссылки

Создать символическую ссылку:
```bash
ln -s original_file symlink_file
```

---

### Поиск

Найти определенный файл:
```bash
find . -depth -iname FIND_NAME -type [f - file, d - каталог]
```

Поиск в файле. -r поиск в подкаталогах:
```bash
grep -i FIND_NAME /path/to/file
```

---

### Операторы объединения

**Оператор амперсанда (&)** - заставит команду работать в фоновом режиме. Просто введите команду с пробелом и ‘&‘. Вы можете выполнить более одной команды в фоновом режиме за один раз.

Примеры:
```bash
ping c5 www.sedicomm.com &
```
```bash
sudo apt update & sudo apt upgrade &
```

**Оператор точка с запятой (;)** - оператор позволяет запускать несколько команд за один раз, и выполнение команды происходит последовательно.

Пример:
```bash
sudo apt update ; sudo apt upgrade ; mkdir test
```

**Оператор AND (&&)** - будет выполнять вторую команду только в том случае, если при выполнении первой команды SUCCEEDS, т.е. состояние выхода первой команды равно «0» — программа выполнена успешно.

Пример:
```bash
ping -c3 www.sedicomm.com && links www.sedicomm.com
```

**Оператор OR (||)** - оператор позволяет вам выполнять вторую команду только в случае сбоя при выполнении первой команды, то есть состояние выхода первой команды равно «1» — программа выполнена НЕ успешно».

Пример:
```bash
sudo apt update || links sedicomm.com
```

**Оператор потока PIPE (|)** - направить вывод команды в другую команду.

Пример:
```bash
ls -l | less
```

**Оператор комбинации команд {}** - объединение команд;

Пример:
```bash
[ -d"bin" ] || { echo Directory does not exist, creating directory now.; mkdir bin; } && echo Directory exists
```

**Оператор приоритета ()** - оператор позволяет выполнить команду в порядке приоритета.

Пример:
(Command_x1 &&Command_x2) || (Command_x3 && Command_x4)

**Оператор конкатенации (\)** - используется для объединения больших команд в нескольких строках оболочки.

Пример:
```bash
nano test\(1\).txt
```

---

### Операторы проверки

Проверка на существование:

```bash
if [ -опция $name ]
```
  - -e - на существование объекта в целом;
  - -d - проверка на существование директории;
  - -f - проверка на существование файла;
  - -s - проверка на файла на пустоту;
  - -h - проверка на файла на символическую ссылку;

---

### Работа со строками/файлами

#### Потоки

"<" - поток stdin\\
">" - поток stdout\\
"2>" - поток err\\

Перенаправить поток ошибок в файл:
```bash
2>lala.txt
```

Перенаправить поток err туда же куда и stdout:
```bash
2>&1
```

Получить имя файла из полного имени (возвращает file.txt):

```bash
basename /var/www/file.txt''
```
  Получить путь до файла файла из полного имени (возвращает /var/www):
```bash
dirname /var/www/file.txt
```

Получить N первых строк из файла
```bash
head --lines=N filename
```

Получить N последних строк из файла
```bash
tail --lines=N filename
```

Удалить дубли строк в файле:
```bash
uniq NAME
```

Сортировка файла:
```bash
sort NAME
```

Замена всех строк и сохранение в том же файле:
```bash
sed -i 's/replace_string/new_string/g' name_file
```

замена нескольких строк
```bash
sed -i -e 's/replace_string_1/new_string_1/g' -e 's/replace_string_2/new_string_2/g' name_file
```

---

### Операторы сравнение целых чисел

- равно
  ```bash
  if [ "$a" -eq "$b" ]
  ```
- не равно
  ```bash
  if [ "$a" -ne "$b" ]
  ```
- больше
  ```bash
  if [ "$a" -gt "$b" ]
  ```
- больше или равно
  ```bash
  if [ "$a" -ge "$b" ]
  ```
- меньше
  ```bash
  if [ "$a" -lt "$b" ]
  ```
- меньше или равно
  ```bash
  if [ "$a" -le "$b" ]
  ```
- проверка на пустоту (существование переменной и пустую переменную - "")
  ```bash
  if [ -z "$b" ]
  ```

В круглых скобках:

- меньше
  ```bash
  (("$a" < "$b"))
  ```
- меньше или равно
  ```bash
  (("$a" <= "$b"))
  ```
- больше
  ```bash
  (("$a" > "$b"))
  ```
- больше или равно
  ```bash
  (("$a" >= "$b"))
  ```

**Раскрытие выражений**

Раскрытие скобок - это создание нескольких строк. Например:

```bash
mkdir /usr/local/src/bash/{old,new,dist,bugs}
```
```bash
/usr/local/src/bash/old
/usr/local/src/bash/new
/usr/local/src/bash/dist
/usr/local/src/bash/bugs
```

Извлечение подстрок. Извлекает подстроку, начиная с start и длиной length
```bash
${string:start:length} 
```
```bash
string="Hello, World!"
echo ${string:0:5} # Вывод: Hello
```

Длина строки. Возвращает длину строки
```bash
${#string}
```

Замена подстроки. Заменяет первое вхождение old на new
```bash
${string/old/new}
```

Заменяет все вхождения old на new
```bash
${string//old/new}
```

Удаление частей строки. Удаляет самое короткое совпадение pattern из начала строки
```bash
${string#pattern}
```

Удаление частей строки. Удаляет самое длинное совпадение pattern из начала строки
```bash
${string##pattern}
```

Удаление частей строки. Удаляет самое короткое совпадение pattern из конца строки
```bash
${string%pattern}
```

Удаление частей строки. Удаляет самое длинное совпадение pattern из конца строки
```bash
${string:%pattern}
```

Преобразование регистра. Приводит строку к нижнему регистру
```bash
${string,,}
```

Преобразование регистра. Приводит строку к верхнему регистру
```bash
${string^^}
```

---

### Циклы

```bash

IFS=$'\n'
file="/etc/passwd"
for var in $(cat $file)
do
  echo " $var"
done

```

```bash

for file in /home/likegeeks/*
do
  if [ -d "$file" ]
  then
    echo "$file is a directory"
  elif [ -f "$file" ]
  then
      echo "$file is a file"
  fi
done

```

---

### Специальные переменные

```bash
$? - статус завершения последней выполненной команды
```
```bash
$0 - имя файла текущего скрипта
```
```bash
$N - аргумент функции/скрипта, где N - номер аргумента
```
```bash
$# - количество аргументов, переданных скрипту
```
```bash
$$ - номер процесса текущей оболочки. Для скриптов оболочки это идентификатор процесса, под которым они выполняются
```

---

### Команды

Подключение файла:
```bash
source filename
```
Пояснение: эта команда позволяет выполнить скрипт в текущем процессе оболочки bash. По умолчанию для выполнения каждого скрипта запускается отдельная оболочка bash, хранящая все его переменные и функции. После завершения скрипта всё это удаляется вместе с оболочкой. Команда source позволяет выполнить скрипт в текущем командном интерпретаторе, а это значит, что всё переменные и функции, добавленные в этом скрипте, будут доступны также и в оболочке после его завершения.

---

### Пакеты

Проверить существование пакета:
```bash
dpkg -s namepackage
```
Посмотреть все установленные пакеты:
```bash
dpkg --get-selections | grep -v deinstall
```

---

### Службы

Получить список загруженных в память обычных служб:
```bash
systemctl list-units --type service
```

Получить список всех служб:
```bash
systemctl list-unit-files
```

---

---

### Порты

Получить список открытых портов:
```bash
ss -tulpn
```

---

### Архивирование

Копирование данных:
```bash
tar
```
Создание архива с файлами и выводом:
```bash
tar --totals -cvf archive.tar file1 file2 file3
```
Просмотр архива и вывод:
```bash
tar -tf archive.tar
```
Распаковка архива:
```bash
tar -xvf archive.tar
```
Распаковка архива в каталог:
```bash
tar -C "/catalog1" -xvf archive.tar
```
Создание архива с файлами и выводом:
```bash
tar --totals -cvf archive.tar file1 file2 file3
```

Разархивирование файлов формата '.gz':
```bash
gunzip имя_архива.gz
```

---

### Передача данных и резервное копирование

Передача данных от сервера в другой сервер:
```bash
rsync -avz name*catalog username@ip_host:/path/to/catalog
```
* a - опция позволяет выполнять рекурсивную синхронизацию, сохраняет символические ссылки, специальные файлы и файлы устройств, время модификации, группу, владельца и права;
_ z - сжатие;
_ v - полная информация о передаче данных;
\_ P - отображение загрузки;

По SSH скачать файл на локальный компьютер с удаленного сервера:
```bash
scp [имя пользователя]@[имя сервера/ip-адрес]:[путь к файлу] [путь к файлу]
```

загрузить файл на сервер по SSH с локальной машины:
```bash
scp [путь к файлу] [имя пользователя]@[имя сервера/ip-адрес]:[путь к файлу]
```

---

### Статистика

- Вывести статистику
  ```bash
  vmstat
  ```
- Выводить статистику с периодом в 1 секунду
  ```bash
  vmstat -n 1
  ```

- Количество занятых fpm воркеров
  ```bash
  ps aux | grep -c fpm
  ```

### Информация о сервер

- получить информацию о системе
  ```bash
  sudo lshw -short
  ```
- получить информацию о процессоре
  ```bash
  sudo lscpu
  ```

---

### Блокировка скрипта

Для выполнения грамотной блокировки скрипта, необходимо понимать, что некоторые скрипты в процессе работы могут создать дочерние оболочки, которые используют свои "собственные блокировки". В общем, вот скрипт:
```bash
(
flock -n 200 || {
exit 1
}

    echo "run"

    sleep 2

    wait

) 200>/tmp/$file_lock
```

''()'' - создает новый контекст оболочки;\\
''flock -n 200'' - команда для блокировки; -n - флаг, отвечающий, что если блокировку произвести нельзя, тогда скрипт возвращает ошибку; 200 - это уникальный дескриптор для блокировки;\\
''||'' - обработка ошибки скрипта; в данном случае выполнится выход из скрипта.
''wait'' - ожидание фоновых процессов;\\
''200>/tmp/$file_lock'' - перенаправление файлового дескриптора 2000 в "файл блокировки" для последующего отслеживания работы\\

## Редакторы

### NANO

Выделение текста:

- сначала отмечается начало выделение: Alt-A или Ctrl-^. Далее следует навигация — и до момента выполнения действия над текстом в буфере, выделение сохраняется;
  Копирование:
- комбинация Alt-6;
  Вырезать:
- комбинация Ctrl-K (или F9);
  Вставить:
- Ctrl-U или F10;
  Удалить:
- комбинация Alt-T (удаляет до указателя мыши);
  Переход на определенный номер строки в файле:
- Ctrl-\_, затем ввод строки;
  Открыть новый файл в nano, не выходя из текущего:
- Команда Ctrl + R (это команда для вставки другого файла);

---

## Утилиты

### logrotate

Предназначена для автоматизации обработки журналов.

Этот файл содержит стандартные параметры и настраивает ротацию для нескольких логов, которые не принадлежат никаким системным пакетам
```bash
/etc/logrotate.conf
```

Узнать версию/проверить наличие:
```bash
logrotate --version
```

Выполнить конфигурацию:
```bash
logrotate -f file_configuration
```

Выполнить конфигурацию в дебаг режиме:
```bash
logrotate -d file_configuration
```

---

### JQ

Предназначена для работы с json файлами

Вывести данные:
```bash
jq . filename
```

Вывести определенный объект из файла:
```bash
jq '.object_name' filename
```

Примеры
```bash
jq '.object_name[2].property' filename
```

Вывести по очереди:
```bash
jq '.object_name[]' filename
```

Вывод json через входящую строку json:
```bash
echo "$json_string" | jq '.name'
```

Вставка аргумента в запрос:
```bash
jq --arg name "$name" '.domains[$name]' "$domains_config"
```

Условия:
```bash
jq --arg name "$name" '.domains[] |= if .name == $name then .property = "value" else . end' "$domains_config"
```

### Crontab

Записать логи crontab:
```bash
\* \* \* \* \* /home/user/test.sh >> /home/user/cron.log 2>&1
```

## Решение багов

Ошибка:
```bash
line 7: $'\r': command not found
```

Появляется тогда, когда файлы Linux редактируются в системе Windows и заменяют стандартный символ перевода строки

Решение:
```bash
sed -i 's/\r$//' "/catalog/to/error/file"
```

Решение для каталога:
```bash

find . -depth -iname _PATTERN_ -type f -exec sed -i 's/\r$//' {} +

```
