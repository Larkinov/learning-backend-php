# GIT

[Официальная документация](https://git-scm.com/book/ru/v2/%d0%92%d0%b2%d0%b5%d0%b4%d0%b5%d0%bd%d0%b8%d0%b5-%d0%9e-%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d0%b5-%d0%ba%d0%be%d0%bd%d1%82%d1%80%d0%be%d0%bb%d1%8f-%d0%b2%d0%b5%d1%80%d1%81%d0%b8%d0%b9)

Справка:

```bash
git --help
```

## Настройки

Посмотреть текущие настройки:

```bash
git config --list
```

Имя пользователя репозитория:

```bash
git config user.name "NAME"
```

Почта пользователя репозитория:

```bash
git config user.email "EMAIL@GMAIL.COM"
```

Сделать настройки глобальными:

флаг --global

## Работа в репозитории

Инициализация репозитория (внутри каталога репозитория!)

```bash
git init
```

Небольшая справка по типам файлов репозитория:

<div>
Каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (неотслеживаемые). Отслеживаемые файлы — это те файлы, которые были в последнем снимке состояния проекта; они могут быть неизменёнными, изменёнными или подготовленными к коммиту. Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.
Неотслеживаемые файлы — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту. Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлёк и вы ничего пока не редактировали.
</div>

### Статусы файлов

Проверить отслеживаемые измененные файлы:

```bash
git status
```
Сокращенный вывод отслеживаемых файлов:

```bash
git status -s
```
Новые неотслеживаемые файлы помечены ?? слева от них, файлы добавленные в отслеживаемые помечены A, отредактированные файлы помечены M и так далее. В выводе содержится два столбца — в левом указывается статус файла, а в правом модифицирован ли он после этого.

### Добавление файлов

Добавить файл в отслеживаемые:

```bash
git add FILENAME
```

<div>Команда «git add FILENAME» - Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния. Индексация изменений подразумевает, что файл отслеживается и был изменен, но для добавления в коммит, его необходимо проиндексировать. Вам может быть понятнее, если вы будете думать о команде «git add» как «добавить этот контент в следующий коммит», а не как «добавить этот файл в проект».
Если отслеживаемый файл был изменен, затем проиндексирован и после снова изменен, то такой файл отправится в коммит с последней версией индексации! То есть после каждого изменения файла, его необходимо проиндексировать чтобы отправить в коммит актуальные изменения.
</div>
  

Добавить несколько файлов в отслеживаемые:

```bash
git add FILENAME_1 FILENAME_2 FILENAME_3
```

Добавить все измененные файлы в индексируемые:

```bash
git add .
```

### Игнорирование файлов

Для игнорирование файлов используется файл:

```bash
.gitignore
```
Примеры:

```bash
# Исключить все файлы с расширением .a
\*.a

# Но отслеживать файл lib.a даже если он подпадает под исключение выше
!lib.a

# Исключить файл TODO в корневом каталоге, но не файл в subdir/TODO
/TODO

# Игнорировать все файлы в каталоге build/
build/

# Игнорировать файл doc/notes.txt, но не файл doc/server/arch.txt
doc/\*.txt

# Игнорировать все .txt файлы в каталоге doc/
doc/\*_/_.txt
```

### Просмотр изменений в файлах

Просмотр разницы между последней версией отслеживаемого файла и непроиндексированной версией этого файла

```bash
git diff
```
Просмотр проиндексированных файлов, которые войдут в коммит:

```bash
git diff --staged
```

### Фиксирование изменений (Коммит изменений)

Зафиксировать изменения (закоммитить):

```bash
git commit
```
Зафиксировать изменения с выводом изменений в файлах:

```bash
git commit -v
```
Зафиксировать изменения с добавленным комментарием:

```bash
git commit -m "Comment"
```
Изменить последний коммит:

```bash
git commit --amend
```

<div>В случае если в индексах будут новые изменения, то команда добавит эти изменения в изменяемый коммит. В случае, если в индексах ничего не было, то это просто изменит комментарий к коммиту.</div>

Изменить последний коммит не меняя комментарий:

```bash
git commit --amend --no-edit
```

### Удаление файлов

Удалить файл из индексируемых (также удалит файл из каталога):

```bash
git rm FILENAME
```

<div>Если просто удалить файл, то он останется в индексах и будет помечен как отслеживаемый и измененный.
Если удалить файл, а затем выполнить команду «git rm», то это удалит файл из индексируемых и в следующем коммите файл исчезнет.
</div>
Удалить файл измененный и проиндексированный файл:

```bash
git rm FILENAME -f
```
Удалить файл из индексируемых, но оставить в рабочем каталоге:

```bash
git rm --cached FILENAME
```

### Перемещение файлов

Для перемещения и переименования:

```bash
git mv FILE_FROM FILE_TO
```

### Отмена изменений

Убрать файл из индекса:

```bash
git reset FILENAME
```
Сдвинуть указатель HEAD на N коммитов и оставить изменения в индексах:

```bash
git reset --soft HEAD~N
```
Сдвинуть указатель HEAD на N коммитов и оставить изменения как не проиндексируемые:

```bash
git reset --mixed HEAD~N
```
Сдвинуть указатель HEAD на N коммитов и удалить все изменения в рабочем каталоге:

```bash
git reset --hard HEAD~N
```
Создать новый коммит на основе предыдущего на N коммита:

```bash
git revert HEAD~N
```
Вернуть файл в первоначальное значение, если он еще не был добавлен в индекс:

```bash
git checkout [filename]
```

### Статистика

Получить статистику по текущему коммиту (какие файлы изменены и что изменено):

```bash
git show
```
Получить сокращенную статистику по текущему коммиту:

```bash
git show --stat
```
Узнать какие файлы были изменены и добавлены в коммит:

```bash
git show --name-only
```

### Перемещение между коммитами

Перемещение между коммитами:

```bash
git checkout [commit hesh] | HEAD~1 (на предыдущий)
```

## Отложенные изменения

Бывают ситуации когда необходимо быстро перенестись в другую ветку, но текущие изменения еще не закончены. Тогда можно отправить текущие изменения в локальное хранилище.

Сохраняет текущие изменения в локальное хранилище:

```bash
git stash
```
Сохранить измененные и не отслеживаемые файлы:

```bash
git stash -u
```
Сохранить все файлы (включая игнорируемые):

```bash
git stash -a
```
Посмотреть текущий список «спрятанных» изменений:

```bash
git stash list
```
Извлечь файлы из локального хранилища в рабочий версию проекта (это удаляет эти файлы из локального хранилища):

```bash
git stash pop
```
Извлечь конкретные «коммиты» локального хранилища:

```bash
git stash pop stash@{идентификатор}
```
Извлечь файлы из локального хранилища в рабочий версию проекта (оставляет файлы в хранилище):

```bash
git stash apply
```
Удалить отложенные изменения:

```bash
git stash drop
```
Удалить конкретные отложенные изменения:

```bash
git stash drop stash@{1}
```
Очистить локальное хранилище:

```bash
git stash drop
```
```bash
git stash clear
```

## Работа с удаленным репозиторием

Клонировать существующий удаленный репозиторий:

```bash
git clone URL
```
Клонировать только ссылки или ветки (без возможности менять файлы):

```bash
git clone URL --mirror
```
Клонировать только одну ветку:

```bash
git clone URL --branch BRANCH_NAME --single-branch
```
Клонировать только файлы корневого каталога:

```bash
git clone URL --sparse
```
Добавить существующий локальный репозиторий в Github:

```bash 
git remote add origin https://github.com/PROFILE_NAME/REPOSITORY_NAME.git
```
«origin» - это стандартное имя сервера с которого клонировался репозиторий. Можно поменять на другое имя.
Просмотр адресов для записи и чтения:

```bash
git remote -v
```
Отправить изменения в удаленный репозиторий (с примером: origin - записанное имя для сервера текущего репозитория, main - имя ветки):

```bash
git push REMOTE_NAME BRANCH_NAME
```
```bash
git push origin main
```
Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а после него выполнить команду push попытаетесь вы, то ваш push точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить push.
«Upstream» режим для отправки - после первого добавления нет необходимости дописывать сервер отправки и имя ветки:

```bash
git push -u <remote-name> <branch-name>
```

## Работа с ветками

Узнать текущие локальные ветки:

```bash
git branch
```
Узнать локальные и удаленные ветки:

```bash
git branch -a
```
Переименовать текущую ветку:

```bash
git branch -M NAME
```
Переименовать существующую ветку

```bash
git branch -m OLD_NAME NEW_NAME
```
Создать новую ветку (только создает):

```bash
git branch NAME
```
Переключиться на другу ветку:

```bash
git checkout NAME
```
Создать и переключиться на новую ветку:

```bash
git checkout -b NAME
```
Переключиться на удаленную ветку:

```bash
git checkout -b NAME REMOTE/BRANCH_NAME
```
Удалить ветку:

```bash
git branch -d BRANCH_NAME
```

## Слияние и изменения

Получить изменения с текущей ветки:

```bash
git fetch
```
Получить изменения со всех веток из репозитория (текущего origin):

```bash
git fetch URL_REPOSITORY
```
Получить изменения с определенной ветки из репозитория:

```bash
git fetch URL_REPOSITORY BRANCH_NAME
```
Получить все изменения с удаленного репозитория и их веток:

```bash
git fetch --all
```
Показать все изменения без получения файлов:

```bash
git fetch --dry-run
```
Слить текущую ветку с веткой BRANCH_NAME:

```bash
git merge BRANCH_NAME
```
Показать какие ветки слиты/не слиты с текущей:

```bash
git merge --merged/--no-merged BRANCH_NAME
```
Получить изменения и слить с текущей локальной веткой:

```bash
git pull URL
```

## История коммитов

Логи:

```bash
git log
```
Флаги:

«BRANCH_NAME» - логи определенной ветки
«-p» - подробные изменения файлов
«–oneline» - короткие коммиты (однострочные)
«–author=NAME» - коммиты определенного автора
«–graph» - график ветвлений
«–decorate» - вывести имена веток
«–all» - просмотр по всем веткам
«-n N» - вывести N записей
«–grep='COMMENT'» - поиск по комментарию
«–since=DATE –until=DATE» - поиск по дате
Посмотреть различия между двумя коммитами:

```bash
git diff NAME_COMMIT_1 NAME_COMMIT_2
```
Посмотреть что изменилось с последнего коммита:

```bash
git diff HEAD
```
Посмотреть что изменилось с предпоследнего коммита:

```bash
git diff HEAD^
```
Сравнить текущую ветку с заданной:

```bash
git diff NAME_BRANCH
```
Статистика измененных файлов:

```bash
git diff --stat
```
Просмотреть файл на полные построчные изменения:

```bash
git blame FILENAME
```
Просмотреть файл на полные построчные изменения в диапазоне:

```bash
git blame FILENAME -L START_STRING,END_STRING
```
Список изменений для файла:

```bash
git log --follow FILENAME
```

## Комментирование в коммитах

Статья на хабре

1. Сначала идет небольшой короткий заголовок, объясняющий суть коммита. Затем идет описание. Заголовок от тела отделяется пустой строкой.

2. Ограничение для заголовок в 50 символах.

3. Заголовок пишется с заглавной буквы.

4. Не ставить точку в конце заголовка.

5. Заголовок в повелительном наклонении?

6. Переход на следующую строку в теле при 72 символах.

7. В теле отвечать на вопросы что (какие изменения) и почему.

Соглашение о коммитах И статья об этом

Шаблон коммита:

<type>[optional область]: <краткое описание>

[optional тело]

[optional подвал]
Основные типы коммитов:

build - Сборка проекта или изменения внешних зависимостей
ci - Настройка CI и работа со скриптами
docs - Обновление документации
feat - Добавление нового функционала
fix - Исправление ошибок
perf - Изменения направленные на улучшение производительности
refactor - Правки кода без исправления ошибок или добавления новых функций
revert - Откат на предыдущие коммиты
chore - Рутинная работа которая ничего не меняет
style - Правки по кодстайлу (табы, отступы, точки, запятые и т.д.)
test - Добавление тестов

## Теги и версионирование

Релиз происходит через добавление тегов. Тег привязывается к текущему коммиту.

Посмотреть список тегов:

```bash
git tag
```
Добавить тег в проект:

```bash
git tag -a 1.0.0 -m "new version"
```
Запушить тег в репозиторий:

```bash
git push origin <tag_name>
```

## Баги

Решение проблемы с символом возврата каретки:

find . -depth -iname _PATTERN_ -type f -exec sed -i 's/\r$//' {} +
